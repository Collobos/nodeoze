#ifndef NODEOZE_RAFT_LOG_H
#define NODEOZE_RAFT_LOG_H

#include <memory>
#include <cstdint>
#include <system_error>
#include <unistd.h>
#include <fcntl.h>
#include <cerrno>
#include <nodeoze/fs2.h>
//#include <nodeoze/bstream/ifbstream.h>
//#include <nodeoze/bstream/ofbstream.h>
#include <nodeoze/bstream/imbstream.h>
#include <nodeoze/bstream/ombstream.h>
#include <nodeoze/bstream/macros.h>
#include <nodeoze/raft/types.h>
#include <nodeoze/raft/state_machine.h>
#include <nodeoze/raft/error.h>
#include <boost/crc.hpp>

#ifndef NODEOZE_RAFT_LOG_FRAME_SIZE_HINT
#define NODEOZE_RAFT_LOG_FRAME_SIZE_HINT  4096ul
#endif // NODEOZE_RAFT_LOG_FRAME_SIZE_HINT

namespace nodeoze
{
namespace raft
{

inline void
clear_error(std::error_code& ec)
{
	static const auto ok = make_error_code( raft::errc::ok );
	ec = ok;
}

using file_position_type = ::off_t;
enum class frame_type
{
	invalid,
	replicant_state_frame,
	state_machine_update_frame,
};

	/*
	*	Requirements for log record types:
	*		ibstream constructible
	*		default constructible (only for return on error conditions, need not be valid )
	*		implement virtual serialize()
	*		copy/move constructible
	*		must support static type() function and get_type()
	*/


class frame : BSTRM_BASE( frame )
{
public:

	inline
	frame()
	:
	m_pos{ -1 }
	{}

	frame( frame const& rhs ) = default;
	frame( frame&& rhs ) = default;

	virtual ~frame() {}

	BSTRM_FRIEND_BASE( frame )
	BSTRM_CTOR( frame, , ( m_pos ) )
	BSTRM_ITEM_COUNT( , ( m_pos ) )

	virtual bstream::obstream&
	serialize(nodeoze::bstream::obstream& os) const
	{
		base_type::_serialize( os );
		os << m_pos;
		return os;
	}
	
	virtual frame_type
	get_type() const noexcept = 0;

	template< class T >
	inline typename std::enable_if_t< std::is_base_of< frame, T >::value, T& >
	as()
	{
		if ( T::type() != get_type() )
		{
			throw std::system_error{ make_error_code( raft::errc::log_frame_type_error ) };
		}
		return reinterpret_cast< T& >( *this );
	}

	inline file_position_type
	file_position() const noexcept
	{
		return m_pos;
	}

	inline void
	file_position(file_position_type pos)
	{
		m_pos = pos;
	}

protected:

	frame_type 				m_type;
	file_position_type 		m_pos;
};

class replicant_state : BSTRM_BASE( replicant_state ), public frame
{
public:
	BSTRM_FRIEND_BASE( replicant_state )
	BSTRM_CTOR( replicant_state, ( frame ) , ( m_self, m_term, m_vote ) )
	BSTRM_ITEM_COUNT( ( frame ) , ( m_self, m_term, m_vote ) )

	static constexpr frame_type
	type()
	{ 
		return frame_type::replicant_state_frame;
	}

	virtual enum frame_type
	get_type() const noexcept override
	{
		return type();
	}

	inline
	replicant_state()
	:
	m_dirty{ false },
	m_self{ 0 },
	m_term{ 0 },
	m_vote{ 0 }
	{}

	inline
	replicant_state( replicant_id_type self, term_type term = 0, replicant_id_type vote = 0 )
	:
	m_dirty{ false },
	m_self{ self },
	m_term{ term },
	m_vote{ vote }
	{}

	replicant_state( replicant_state const& rhs ) = default;

	replicant_state( replicant_state&& rhs ) = default;

	replicant_state&
	operator=( replicant_state const& ) = delete;

	replicant_state&
	operator=( replicant_state&& ) = delete;

	virtual bstream::obstream&
	serialize(nodeoze::bstream::obstream& os) const override
	{
		base_type::_serialize( os );
		frame::serialize( os );
		os << m_self << m_term << m_vote;
		return os;
	}

	inline void
	update( replicant_state const& rhs )
	{
		if ( rhs.m_self != m_self )
		{
			throw std::system_error{ make_error_code( raft::errc::log_server_id_error ) };
		}
		term( rhs.term() );
		vote( rhs.vote() );
	}

	inline void
	update( replicant_state const& rhs, std::error_code& ec )
	{
		clear_error( ec );
		if ( rhs.m_self != m_self )
		{
			ec = make_error_code( raft::errc::log_server_id_error );
		}
		else
		{
			term( rhs.term() );
			vote( rhs.vote() );
		}
	}

	inline void
	clean()
	{
		m_dirty = false;
	}

	inline void
	clear( replicant_id_type self )
	{
		m_self = self;
		m_dirty = false;
		m_term = 0;
		m_vote = 0;
	}

	inline replicant_id_type
	self() const noexcept
	{
		return m_self;
	}

	inline term_type
	term() const noexcept
	{
		return m_term;
	}

	inline replicant_id_type
	vote() const noexcept
	{
		return m_vote;
	}

	inline void
	term( term_type trm )
	{
		assert( trm >= m_term );
		if ( trm != m_term )
		{
			m_dirty = true;
			m_term = trm;
		}
	}

	inline void
	vote( replicant_id_type id )
	{
		if ( id != m_vote )
		{
			m_dirty = true;
			m_vote = id;
		}
	}

	inline bool
	is_dirty() const noexcept
	{
		return m_dirty;
	}

private:
	bool						m_dirty = false;
	replicant_id_type			m_self;
	term_type					m_term;
	replicant_id_type			m_vote;
};

class entry : BSTRM_BASE( entry ), public frame
{
public:

	entry( term_type term, index_type index )
	:
	frame{},
	m_term{ term },
	m_index{ index }
	{}

	inline
	entry()
	:
	frame{},
	m_term{ 0 },
	m_index{ 0 }
	{}

	entry( entry const& rhs ) = default;
	entry( entry&& rhs ) = default;

	BSTRM_FRIEND_BASE( entry )
	BSTRM_CTOR( entry, ( frame ), ( m_term, m_index ) )
	BSTRM_ITEM_COUNT( ( frame ) , ( m_term, m_index ) )

	virtual bstream::obstream&
	serialize(nodeoze::bstream::obstream& os) const
	{
		base_type::_serialize( os );
		frame::serialize( os );
		os << m_term << m_index;
		return os;
	}

	inline index_type
	index() const noexcept
	{
		return m_index;
	}
	
	inline term_type
	term() const noexcept
	{
		return m_term;
	}

protected:

	term_type					m_term;
	index_type					m_index;
};

class state_machine_update : BSTRM_BASE( state_machine_update ), public entry
{
public:
	BSTRM_FRIEND_BASE( state_machine_update )
	BSTRM_ITEM_COUNT( ( entry ), ( m_payload ) )
	BSTRM_CTOR( state_machine_update, ( entry ), ( m_payload ) )

	virtual bstream::obstream&
	serialize(nodeoze::bstream::obstream& os) const override
	{
		base_type::_serialize( os );
		entry::serialize( os );
		os << m_payload;
		return os;
	}

	inline
	state_machine_update( term_type term, index_type index, buffer&& payload )
	:
	entry{ term, index },
	m_payload{ std::move( payload ) }
	{}

	inline
	state_machine_update()
	:
	entry{},
	m_payload{}
	{}

	static constexpr frame_type
	type()
	{ 
		return frame_type::state_machine_update_frame;
	}

	virtual frame_type
	get_type() const noexcept override
	{
		return type();
	}

private:
	buffer	m_payload;
};

class log
{
public:

	log( replicant_id_type id, std::string const& log_pathname, std::string const& log_temp_pathname )
	:
	m_self{ id },
	m_state{ id },
	m_log_pathname{ log_pathname },
	m_log_temp_pathname{ log_temp_pathname },
	m_frame_writer{ NODEOZE_RAFT_LOG_FRAME_SIZE_HINT }
	{}

	void
	initialize( replicant_id_type self, bool clean, std::error_code& err )
	{
		clear_error( ec );
		m_self = self;
		m_state.clear( self );
		m_log.clear();

		if ( clean )
		{
			path tmp_path{ m_log_temp_pathname };
			if (fs::shared().exists( path{ tmp_path } ) )
			{
				err = fs::shared().unlink( tmp_path );
				if ( err ) goto exit;
			}

			open_for_write( m_log_pathname.cstr(), err );
			if ( err ) goto exit;
		}
		else
		{
			path tmp_path{ m_log_temp_pathname };
			if (fs::shared().exists( path{ tmp_path } ) )
			{
				err = fs::shared().unlink( tmp_path );
				if ( err ) goto exit;
			}

			recover( err );
			if ( err ) goto exit;

			open_for_write( m_log_pathname.cstr(), err );
			if ( err ) goto exit;
		}

	exit:
		return;
	}

	inline void
	close( std::error_code& ec )
	{

		auto status = ::close( m_out );
		if ( status < 0 )
		{
			err = std::error_code{ errno, std::generic_category() };
			goto exit;
		}

		m_out_pos = -1;

	exit:
		return;
	}

	inline void
	append( std::unique_ptr< entry > entry_ptr, std::error_code& err )
	{
		m_log.push_back( std::move( entry_ptr ) );

		write_frame( *m_log.back(), err );
	}

	inline void
	update_replicant_state( replicant_state const& new_state, std::error_code& ec )
	{
		m_state.update( new_state );
		if ( m_state.is_dirty() )
		{
			write_frame( m_state, ec );
			if ( ! ec )
			{
				m_state.clean();
			}
		}
	}

	inline replicant_state const&
	current_replicant_state() const
	{
		return m_state;
	}

	void
	write_frame( frame& f, bool flush = true )
	{
		f.file_position( m_out_pos );
		m_frame_writer.clear();
		m_frame_writer.put_num( static_cast< std::uint32_t >( 0 ) );
		m_frame_writer.put_num( static_cast< std::uint32_t >( f.get_type() ) );
		m_frame_writer << f;
		m_frame_writer.position( 0 );
		m_frame_writer.put_num( static_cast< std::uint32_t >( m_frame_writer.size() ) );
		m_frame_writer.position_at_end();

		auto frame_buffer = m_frame_writer.get_buffer();
		boost::crc_32_type crc;
		crc.process_bytes( frame_buffer.const_data(), frame_buffer.size() );
		m_frame_writer.put_num( static_cast< std::uint32_t >( crc.checksum() ) );

		write_buffer( m_frame_writer.get_buffer(), err );
	}
	
	std::pair< std::uint32_t, frame_type >
	read_frame_prefix( file_descriptor_type fd, std::error_code& err )
	{
		std::uint32_t prefix;
		auto n = ::read( fd, &prefix, sizeof( frame_size ) );
		if ( n < 0 )
		{
			err = std::error_code{ errno, std::generic_category() };
			goto exit;
		}
		std::uint32_t frame_size = boost::endian::big_to_native( prefix );
		buffer frame_buffer{ frame_size + sizeof( std::uint32_t ) };
		frame_buffer.put( 0, &prefix, sizeof( prefix ) );
		n = ::read( fd, frame_buffer.mutable_data() + sizeof( prefix ), frame_size );
		if ( n < 0 )
		{
			err = std::error_code{ errno, std::generic_category() };
			goto exit;
		}
		if ( n < frame_size )
		{
			err = make_error_code( raft::errc::log_incomplete_record );
			goto exit;
		}
		boost::crc_32_type crc;
		crc.process_bytes( frame_buffer.const_data(), frame_size );
		std::uint32_t chksum = crc.checksum();
		
		bstream::imbstream is{ std::move( frame_buffer ) };
		auto size_check = is.get_num< std::uint32_t >();
		assert( size_check == frame_size );
		frame_type ftype = static_cast< frame_type >( is.get_num< std::uint32_t >() );
		std::unique_ptr< frame > fptr = nullptr;
		switch ( ftype )
		{
			case frame_type::replicant_state_frame:
			{
				fptr = std::make_unique< replicant_state >( is );
				... check for errors
			}
			...
		}

		std::uint32_t buf_chksum = is.get_num< std::uint32_t >();
		if ( chksum != buf_chksum )
		{
			err = make_error_code( raft::errc::log_checksum_error );
			goto exit;
		}

	exit:
		return fptr;
	}

	template< class T >
	T
	read_frame( bstream::ifbstream& is )
	{
		buffer framebuf = is.read_blob();
		auto buffer_checksum = framebuf.checksum();
		auto frame_checksum = is.get_num< buffer::checksum_type >();
		if ( buffer_checksum != frame_checksum )
		{
			throw std::system_error{ make_error_code( raft::errc::log_checksum_error ) };
		}
		assert( framebuf.is_unique() );
		bstream::imbstream framebuf_strm{ std::move( framebuf ) };
		assert( framebuf_strm.get_membuf().get_buffer_ref().is_unique() );
		return T{ framebuf_strm };
	}

	template< class T >
	std::unique_ptr< T >
	read_frame_as_unique_ptr( bstream::ifbstream& is )
	{
		buffer framebuf = is.read_blob();
		auto buffer_checksum = framebuf.checksum();
		auto frame_checksum = is.read_as< buffer::checksum_type >();
		if ( buffer_checksum != frame_checksum )
		{
			throw std::system_error{ make_error_code( raft::errc::log_checksum_error ) };
		}
		assert( framebuf.is_unique() );
		bstream::imbstream framebuf_strm{ std::move( framebuf ) };
		assert( framebuf_strm.get_membuf().get_buffer_ref().is_unique() );
		return std::make_unique< T >( framebuf_strm );
	}

	void
	recover( std::error_code& ec )
	{
		if ( !fs::shared().exists( path( m_log_pathname ) ) )
		{
			ec = make_error_code( std::errc::no_such_file_or_directory );
		}
		else
		{
			try 
			{		
				bstream::ifbstream is;
				is.open( m_log_pathname );
				std::size_t file_size = is.size();
				m_state.clear( m_self );

				file_position_type frame_position = is.position();
				while ( static_cast< std::size_t >( frame_position ) < file_size )
				{
					auto header = read_frame_prefix( is );
					switch ( header.second )
					{
						case frame_type::replicant_state_frame:
						{
							auto repl_state = read_frame< replicant_state >( is );
							assert( repl_state.file_position() == frame_position );
							m_state.update( repl_state );
						}
						break;

						case frame_type::state_machine_update_frame:
						{
							m_log.push_back( read_frame_as_unique_ptr< state_machine_update >( is ) );
							assert( m_log.back()->file_position() == frame_position );
						}
						break;

						default:
						{
							throw std::system_error{ make_error_code( raft::errc::log_frame_type_error ) };
						}
					}
					frame_position = is.position();
				}

				if ( ! m_state.is_dirty() )
				{
					throw std::system_error{ make_error_code( raft::errc::log_recovery_error ) };
				}
				is.close();
			}
			catch ( std::system_error const& e )
			{
				ec = e.code();
			}
		}
	}

	inline bool
	empty() const
	{
		return m_log.empty();
	}

	inline const entry&
	back() const
	{
		if ( m_log.empty() )
		{
			throw std::system_error{ make_error_code( raft::errc::log_index_out_of_range ) };
		}
		return *m_log.back();
	}

	inline const entry&
	front() const
	{
		if ( m_log.empty() )
		{
			throw std::system_error{ make_error_code( raft::errc::log_index_out_of_range ) };
		}
		return *m_log.front();
	}

	inline const entry&
	operator[](index_type index) const
	{
		if (index_check(index))
		{
			throw std::system_error{ make_error_code( raft::errc::log_index_out_of_range ) };
		}
		auto i = index - front_index();
		return *m_log[i];
	}

	/*
	 *  remove entries with indices higher than the specified index
	 */
	void
	prune_back(index_type index, std::error_code& ec)
	{
		clear_error( ec );
		assert( ! m_log.empty() );
		if ( index < m_log.front()->index() || index > m_log.back()->index() )
		{
			ec = make_error_code( std::errc::invalid_argument );
			goto exit;
		}

		if ( index < m_log.back()->index() )
		{
			file_position_type truncate_at = m_log.back()->file_position();
			while( ! m_log.empty() && m_log.back()->index() > index )
			{
				truncate_at = m_log.back()->file_position();
				m_log.pop_back();
			}
			if ( m_log.empty() || m_log.back()->index() != index )
			{
				ec = make_error_code( std::errc::state_not_recoverable );
				goto exit;
			}
			truncate( truncate_at, ec );
			if ( ec ) goto exit;
		}

	exit:
		return;
	}

	/*
	 *  remove entries with indices lower than the specified index
	 */
	void
	prune_front(index_type index, std::error_code& ec)
	{
		clear_error( ec );
		assert( ! m_log.empty() );
		if ( index < m_log.front()->index() || index > m_log.back()->index() )
		{
			ec = make_error_code( std::errc::invalid_argument );
		}
		else
		{
			try
			{
				if ( index > m_log.front()->index() )
				{
					while( ! m_log.empty() && m_log.front()->index() < index )
					{
						m_log.pop_front();
					}

					if ( m_log.empty() || m_log.front()->index() != index )
					{
						throw std::system_error{ make_error_code( std::errc::state_not_recoverable ) };
					}

					m_os.close();
					m_os.open( m_log_temp_pathname, bstream::ofbstream::open_mode::truncate );

					for ( auto it = m_log.begin(); it != m_log.end(); ++it )
					{
						auto pos = m_os.position();
						(*it)->file_position( pos );
						write_frame( *( *it ), false );
					}

					write_frame( m_state );
					m_os.close();

					auto ecode = fs::shared().move( path{ m_log_temp_pathname }, path{ m_log_pathname } );
					if ( ecode )
					{
						throw std::system_error{ ecode };
					}

					m_os.open( m_log_pathname, bstream::ofbstream::open_mode::append );
				}
			}
			catch ( std::system_error const& e )
			{
				ec = e.code();
			}
		}

		if ( ec && m_os.is_open() )
		{
			std::error_code discard;
			m_os.close( discard );
		}
	}
	
protected:

	void
	truncate( file_position_type pos, std::error_code& err )
	{
		clear_error( err );
		auto result = ::truncate( m_out, static_cast< off_t >( pos ) );
		if ( result < 0 )
		{
			ec = std::error_code{ errno, std::generic_category() };
		}
		m_out_pos = pos;
	}


	inline void
	write_buffer( buffer const& buf, std::error_code& err )
	{
		clear_error( err );
		auto n = ::write( m_out, buf.const_data(), buf.size() );
		if ( n < 0 )
		{
			err = std::error_code{ errno, std::generic_category() };
		}
		else
		{
			assert( n == buf.size() );
			m_out_pos += n;
		}
	}

	inline void
	open_for_write( std::string const& pathname, std::error_code& err )
	{
		clear_error( err );
		m_out = ::open( m_log_pathname.cstr(), ( O_WRONLY | O_APPEND | O_CREAT ) );
		if ( m_out < 0 )
		{
			err = std::error_code{ errno, std::generic_category() };
			goto exit;
		}
		m_out_pos = ::lseek( m_out, 0, SEEK_END );
		if ( m_out_pos < 0 )
		{
			err = std::error_code{ errno, std::generic_category() };
			goto exit;
		}
	exit:
		return;
	}

	bool 
	index_check(index_type index) const noexcept
	{
		return !m_log.empty() && index >= front_index() && index <= back_index();
	}
	
	bool
	integrity_check() const noexcept
	{
		return m_log.empty() || (m_log.size() == ((m_log.back()->index() + 1) - m_log.front()->index()));
	}

	replicant_id_type							m_self;
	replicant_state								m_state;
	std::string									m_log_pathname;
	std::string									m_log_temp_pathname;
	file_descr_type								m_out;
	file_position_type							m_out_pos;
	std::deque< std::unique_ptr< entry > > 		m_log;
	bstream::ombstream							m_frame_writer;
};

} // namespace raft
} // namespace nodeoze

#endif // NODEOZE_RAF_LOG_H
